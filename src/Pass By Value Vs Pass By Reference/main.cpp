#include <iostream>

using namespace std;


class MyClass {
public:
    int value;

    MyClass(int value) : value(value) {} // Member Initializer list. It's a way to initialize class members directly before the body of the constructor executes. Initializer list already understands this-> syntax.

    // Constructor that initializes the member variable inside the constructor body
    /*MyClass(int value) {
        this->value = value;
    }*/
    
    void display() const {
        cout << "Value: " << value << endl;
    }
};

// Function that takes an object by value
void passByValue(MyClass obj) { // When an object is passed by value to a function, a copy of the object is created. This copy has its own memory location separate from the original object. Any changes made to this copy do not affect the original object.
    obj.value = 20;
    cout << "Inside passByValue: ";
    obj.display();
}

// Function that takes an object by reference or by memory address
void passByReference(MyClass& obj) { // & - Means reference operator and it takes the address of some passed argument. Any modifications to the object will be reflected since were pointing at the smae memory address.
    obj.value = 30;
    cout << "Inside passByReference: ";
    obj.display();
}

// Function that takes an object by pointer
void passByPointer(MyClass* obj) {
    obj->value = 40;
    cout << "Inside passByPointer: ";
    obj->display();
}



int main() {
    MyClass obj(10); // Memory for this object is allocated on the stack

    cout << "Original object: ";
    obj.display();
    cout << "----------------------------------------------------\n" << endl;

    passByValue(obj);
    cout << "After passByValue: ";
    obj.display();
    cout << "----------------------------------------------------\n" << endl;

    passByReference(obj);
    cout << "After passByReference: ";
    obj.display();
    cout << "----------------------------------------------------\n" << endl;

    passByPointer(&obj); // You are passing the address of obj to the function passByPointer. This means you are passing a pointer to obj. This address is of type MyClass* (a pointer to MyClass).
    // Pointers * hold addresses like the one generated by &
    // But in the first part you are still passing by value but the compiler sees & so it handles the pointer behavior under the hood for you.
    cout << "After passByPointer: ";
    obj.display();
    cout << "----------------------------------------------------\n" << endl;

    MyClass* pointerObj = new MyClass(8);
    passByPointer(pointerObj); // new MyClass(8);
    cout << "After passByPointer: ";
    obj.display();
    cout << "----------------------------------------------------\n" << endl;

    return 0;
}

/*
Pass by Reference:
When a function is called with pass-by-reference, the compiler generates code to pass the address of the variable to the function. The function then uses this address to directly access the variable.
This is essentially syntactic sugar for passing pointers but is safer and more convenient because it avoids pointer-related issues.
When you use pass-by-reference in C++, the compiler handles the pointer details for you behind the scenes.

Pass by Pointer:
When a function is called with pass-by-pointer, the compiler passes the address of the variable explicitly. Inside the function, this address is used to access and modify the variable via dereferencing.

Requires explicit handling of pointers, including checking for nullptr and ensuring the pointer is valid.
*/
